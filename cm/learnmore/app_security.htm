---
layout: page
title: App Security
description: Learn about how to set up and manage app security.
product: cm
category: learn
subcategory: App Security
weight: 22
type: page
nav-title: App Security
---

<h2 id="top">App Security</h2>

<p>The default authentication for  SOA Software Open is a custom authentication mechanism, Shared Secret authentication.</p>
<p>It's important to set up authentication for the messages  your app sends to an API you&rsquo;re using. Authentication protects the sender, the receiver, and the  message itself. It&rsquo;s important that the security is strong enough that a third  party couldn&rsquo;t pose as the sender, pose as the receiver, and/or view or change  the message content.</p>
<p>Authentication and security are particularly important when  money and sensitive personally identifiable information are involved.</p>
<p>Once your app is registered, it's important to set up authentication so that the app can use the API to process messages securely.</p>
<p>In SOA Software Open, as part of setting up your app, you&rsquo;ll need  to choose the security  mechanism you&rsquo;ll use for authentication of your messages. There are two  choices:</p>
<ul>
  <li>Shared Secret (the default)</li>
  <li>Public Key Infrastructure</li>
</ul>


<h5>What do you want to read about?</h5>
<ul>
  <li><a href="#whichtochoose">Which Security Mechanism Should I Choose?</a>
  <li><a href="#authenticating_ss">Authenticating with the Shared Secret</a>
    <ul>
  <li><a href="#processflow_ss">Authenticating with the Shared Secret: Process Flow</a></li>
  <li><a href="#sampleheader">Sample Header With Authorization Parameters (Shared Secret Approach)</a></li>
  <li><a href="#generatingnonce">Generating a Nonce Value</a></li>
  <li><a href="#generatingtimestamp">Generating the Timestamp</a></li>
  <li><a href="#hashing_sha1">Hashing With the SHA-1 Secure Hash Algorithm</a></li>
  <li><a href="#encoding_base64">Encoding with the Base64 Encoding Scheme</a></li>
    <li><a href="#troubleshooting_ss">Troubleshooting (Shared Secret Approach)</a></li>
    <li><a href="#compromise_ss">What If the Shared Secret Is Compromised?</a></li>
  <li><a href="#compromise_ss">Java Example: Creating a Shared Secret Hash</a></li
    ></ul>
</li>
    <li><a href="#authenticating_pki">Authenticating with PKI</a>
    <ul>
  <li><a href="#processflow_pki">Authenticating with PKI: Process Flow</a></li>
  <li><a href="#generatingkeypairwithopenssl">Generating a Public/Private Key Pair with OpenSSL</a></li>
  <li><a href="#signing">Signing REST-Based Web Service Requests (PKI)</a></li>
  <li><a href="#composing">Composing the Signature</a></li>
    </ul>
</li>
  <li><a href="#headerexamplebothapproaches">Header Example for Both Approaches</a></li>
</ul>
<p class="apidoc_note"><strong>Note</strong>: This topic provides information about setting up authentication for any API hosted in SOA Software Open. For implementation information and examples for a specific API you're using, refer to the documentation for that API.</p>
<hr>



<a name="whichtochoose"></a><h3>Which Security Mechanism Should I Choose?</h3>
<p>Both approaches are very secure. Both use a secret key combined with hashing and encoding, and both are sent via HTTPS.</p>
<p>The Shared Secret approach, which is the default, is easier to implement since you don't have to generate public and private keys.</p>
<p>The PKI approach is a little more secure, although both approaches are very secure. The PKI approach is more complex to implement.</p>
<p><a href="#top">Back to top</a></p>
<hr>



<a name="authenticating_ss"></a><h3>Authenticating with the Shared Secret</h3>
<p>When you register your app, the AppID and Shared Secret are  automatically generated. The Shared Secret is a binary hashed value, generated within the secure environment of SOA Software Open and known only  to you and to SOA Software Open. In  the <em>Security Credentials</em> section of the App Details screen you'll see that the Shared Secret option is the default security mechanism.</p>
<p>The Shared Secret approach follows the WS-Security digest authentication  mechanism.</p>
<p>The Shared Secret, generated by  SOA Software Open, is a 40-character alphanumeric value that acts as the key. An example is shown below.</p>
<pre class="apidoc_pre"><a name="example_sharedsecret"></a>1008877afabf32efb31f9c974dbeaa688bed0769</pre>
<p>You combine the Shared Secret with two other values, hash the  result using the SHA-1 secure hashing algorithm, and then encode the hashed value using the Base64 encoding scheme. You can also URL-encode the result, but this isn't required.</p>
<p>The result is sent in the HTTP Authorization  message header as the value for the atmosphere_secret_digest parameter.</p>
<p>The API verifies each incoming request using the Shared Secret.</p>
<p>If you choose the Shared Secret security mechanism, your  HTTP Authorization header must include the values shown below.</p>
<table width="98%" cellpadding="2" cellspacing="0" class="tableparmsresponse" summary="table description">
  <thead>
    <tr>
      <th width="25%">Name</th>
      <th width="20%">Data Type</th>
      <th width="55%">Description</th>
    </tr>
  </thead>
  <tbody>
  <tr>
    <td valign="top">atmosphere_app_id</td>
    <td valign="top">String</td>
    <td valign="top">The AppID assigned to the app in the platform.</td>
  </tr>
  <tr>
    <td valign="top">atmosphere_nonce</td>
    <td valign="top">String</td>
    <td valign="top">A random string, uniquely generated for each request. For more information, see <a href="#generatingnonce">Generating a Nonce Value</a>.</td>
  </tr>
  <tr>
    <td valign="top">atmosphere_secret_digest</td>
    <td valign="top">String</td>
    <td valign="top">A value produced by concatenating the nonce, the timestamp, and the Shared Secret, hashing the combined value using SHA-1, and then Base-64 encoding the result. You can also URL-encode the result but this isn't required.</td>
  </tr>
  <tr>
    <td valign="top">atmosphere_signature_method</td>
    <td valign="top">String</td>
    <td valign="top">A value indicating the signature method. For the Shared Secret approach, the valid value is <strong>Digest</strong>.</td>
  </tr>
  <tr>
    <td valign="top">atmosphere_timestamp</td>
    <td valign="top">String</td>
    <td valign="top">The timestamp of the request, expressed as the number of milliseconds since January 1, 1970 00:00:00 GMT. The timestamp must be a positive integer and must be greater than or equal to the timestamp used in previous requests.</td>
  </tr>
 <tr>
      <td>atmosphere_version</td>
      <td>String</td>
      <td>The SOA Software Open version. Optional. If present, the valid value must be 1.0.</td>
  </tr>  
  </tbody>
</table>
<p>More information about the shared secret approach is given in these  sections:</p>
<ul>
  <li><a href="#processflow_ss">Authenticating with the Shared Secret: Process Flow</a></li>
  <li><a href="#sampleheader">Sample Header With Authorization Parameters (Shared Secret Approach)</a></li>
  <li><a href="#generatingnonce">Generating a Nonce Value</a></li>
  <li><a href="#generatingtimestamp">Generating the Timestamp</a></li>
  <li><a href="#hashing_sha1">Hashing With the SHA-1 Secure Hash Algorithm</a></li>
  <li><a href="#encoding_base64">Encoding with the Base64 Encoding Scheme</a></li>
  <li><a href="#troubleshooting_ss">Troubleshooting (Shared Secret Approach)</a></li>
  <li><a href="#compromise_ss">What If the Shared Secret Is Compromised?</a></li>
  <li><a href="#compromise_ss">Java Example: Creating a Shared Secret Hash</a></li>
</ul>

<h4><a name="processflow_ss"></a>Authenticating with the Shared Secret: Process Flow</h4>
<p> The process flow diagram below shows an overview of API request authentication with the shared secret security mechanism.</p>
<p class="apidoc_image_p"><img src="images/processflow_apirequestauth_ss2.jpg" alt="Process flow: shared secret security mechanism"></p>

<h4><a name="sampleheader"></a>Sample Header With Authorization Parameters (Shared Secret Approach)</h4>
<p>Below is an example of an Authorization header with app authentication parameters, when you use the shared secret approach. The sequence of the parameters isn't significant, but all parameters must be present with valid values.</p>
<p class="apidoc_note"><strong>Note</strong>: The value for the  realm is determined by the www-Authenticate header. Make sure the value you set in the Authorization: SOA Software Open header matches the value received for the attribute from the server.</p>
<pre class="apidoc_pre">Authorization: Atmosphere realm="http://atmosphere",
  atmosphere_app_id="development-AS0iTmhoGaE6Y9sWhUkvcL6T",
  atmosphere_nonce="1326409129918",
  atmosphere_secret_digest="wOJIO9A2W5mFwDgiDvZbTSMK%2FPY%3D",
  atmosphere_digest_method="SHA1",
  atmosphere_timestamp="1326755565940",
  atmosphere_version="1.0"
</pre>
<a name="generatingnonce"></a><h4>Generating a Nonce Value</h4>
<p>A nonce is a random string that is uniquely generated for each request. The nonce allows the API providers to verify that a request has never been made before. A nonce is sent in the message header for both Shared Secret and PKI security mechanisms. In the Shared Secret mechanism, the same nonce value sent in the message header is also used in creating the Secret Digest.</p>
<p>The way you create the nonce will depend on your development environment. Most programming languages include a method for creating a nonce. Below is an example of generating a nonce value in Java:</p>
<pre class="apidoc_pre">Import java.security.SecureRandom:
Random rand =  SecureRandom.getInstance ("SHA1PRNG");
long nonce = rand.nextLong();</pre>
<!--<p>For more information on the nonce, and examples of inplementation in different programming languages, see <span class="apidoc_red">www.xxx.com</span>.</p>
<p><span class="apidoc_red">{{More nonce examples?}}</span></p>-->
<a name="generatingtimestamp"></a><h4>Generating the Timestamp</h4>
<p>The timestamp of the request is sent in the message header, for both Shared Secret and PKI security mechanisms. In the Shared Secret mechanism it is also used in creating the  Secret Digest.</p>
<p> The timestamp must be in Unix epoch time, expressed as the number of milliseconds since January 1, 1970 00:00:00 GMT. The timestamp must be a positive integer and must be greater than or equal to the timestamp used in previous requests. In most implementations, the timestamp is taken from the host server. It's important that the timestamp in the message is accurate; if the timestamp is off, the message might be rejected.</p>
<p>For more information on Unix epoch time, and examples of implementation of the timestamp in different programming languages, see <a href="http://www.epochconverter.com" target="_blank">http://www.epochconverter.com</a> (scroll down).</p>
<a name="hashing_sha1"></a><h4>Hashing With the SHA-1 Secure Hash Algorithm</h4>
<p>SHA-1 is a cryptographic hash function, broadly used and trusted.</p>
<p>When you hash a value with SHA-1, the hash function returns a 160-bit string. This is the message digest. The value is hashed and sent with the message; at the receipt point, the value is hashed again, and the two hash values are compared. When the two hash values match, it is a secure, reliable indication that the message hasn't changed; the message at the receipt point is an accurate duplication of the message at the send point.</p>
<p>If you're using the Shared Secret security mechanism, you concatenate the nonce, the timestamp, and the Shared Secret, and then you hash that combined value using SHA-1. You then encode the result, and send it in the message header as the value for the atmosphere_secret_digest parameter.</p>
<p>The formula for computing the hash is:</p>
<pre class="apidoc_pre">atmosphere_secret_digest = Base64 ( SHA-1 ( nonce + created + AppSecret ) ) </pre>
<p>Below is an example of a hashed base string:</p>
<pre class="apidoc_pre">
1326409129918+1326755565940+2d9d42b42a4e2abc1fa5489d5081e03b95818ffd </pre>
<h4>Encoding the base string into bytes</h4>
<p>When you concatenate the nonce, timestamp, and app secret into a base string to be hashed, you'll need to make sure the concatenated value is a byte value before hashing. The hashing algorithm requires the input parameter to be in bytes. Depending on your app, you might need to use encoding to get a byte value. If so, use UTF-8 encoding. 
<p>Below is an example using Java.</p>

<!--<pre class="apidoc_pre">
MessageDigest md = MessageDigest.getInstance("SHA1"); 
md.update(baseString.getBytes("UTF-8"));
  // AnyBase64 implementation can be used to convert digest bytes 
  // to text representation. Make sure no chunking is done after 76 characters.
  // The entire Base64-encoded digest should be in one line.
  // Apache commons coded library reference for Base64 class is available at:
  // http://commons.apache.org/codec/apidocs/org/apache/commons/codec/binary/Base64.htm
org.apache.commons.codec.binary.Base64 base64Obj = new org.apache.commons.codec.binary.Base64();
String digest = base64Obj.encodeBase64String(md.digest());</pre>-->
<pre class="apidoc_pre">
MessageDigest md = MessageDigest.getInstance("SHA1"); 
md.update(baseString.getBytes("UTF-8")); or
md.update(baseString.getBytes()); 
String digest = encodeAsBase64String(md.digest()); </pre>

<p class="apidoc_note"><strong>Note</strong>: The example above is part of a larger Java sample for a specific API. For more information, refer to the implementation examples for the API you're using.</p>
<a name="encoding_base64"></a><h4>Encoding with the Base64 Encoding Scheme</h4>
<p>The Base64 encoding scheme converts binary data into an ASCII string.</p>
<p>If you're using the Shared Secret security mechanism, you must encode the binary hash value that you created using the SHA-1 secure hash algorithm. Encoding turns it into ASCII string format. It's common practice to encode data to make sure it remains intact without modification during transport by HTTP or HTTPS.</p>
<p>Once the hash is encoded, the next step is to send the encoded value in the message header as the value for the atmosphere_secret_digest parameter.</p>
<a name="troubleshooting_ss"></a><h4>Troubleshooting (Shared Secret Approach)</h4>
<p>If there's a problem with your HTTPS header, you might see one of the error messages shown below.</p>
<!--<p>{{Queries and suggested text changes on error messages.}}</p>-->
<table width="84%" cellpadding="2" cellspacing="0" class="tableparmsresponse" summary="table of error messages">
  <thead>
    <tr>
      <th width="10%">Code</th>
      <th width="66%">Description</th>
    </tr>
  </thead>
  <tbody>
  <tr>
  <td>1010701</td>
  <td>Required HTTP header parameter missing. [<strong>{0}</strong>]</td>
  </tr>
  <tr>
  <td>1010702</td>
  <td>One or more invalid HTTP header parameters.</td>
  </tr>
  <tr>
  <td>1010703</td>
  <td>Invalid <u>Nonce</u>. The value of the atmosphere_nonce field has already been used.</td>
  </tr>
  <tr>
  <td>1010704</td>
  <td>Invalid timestamp. The value of the atmosphere_timestamp field is out of range.</td>
  </tr>
  <tr>
  <td>1010705</td>
  <td>Signature or digest algorithm is not supported. [<strong>{0}</strong>]</td>
  </tr>
  <tr>
  <td>1010706</td>
  <td>Signature or digest verification failed.</td>
  </tr>
  <tr>
  <td>1010707</td>
  <td>Missing nonce. The atmosphere_nonce field value is required.</td>
  </tr>
  <tr>
  <td>1010708</td>
  <td>Unable to verify signature. There is no public key associated with the app.</td>
  </tr>
  <tr>
  <td>1010709</td>
  <td>Authentication scheme is invalid or missing.</td>
  </tr>
  <tr>
  <td>1010710</td>
  <td>Invalid AppID. The value [{0}] in the atmosphere_app_id field is invalid or missing.</td>
  </tr>
  <tr>
  <td>1010711</td>
  <td>Unable to verify signature. There is no shared secret associated with the <u>app</u>.</td>
  </tr>
  <tr>
  <td>1010712</td>
  <td>Invalid timestamp. Timestamp must be Unix epoch time in milliseconds.</td>
  </tr>
</table>

<a name="compromise_ss"></a><h4>What If the Shared Secret Is Compromised?</h4>
<p>If for any reason you know or suspect that your app's Shared Secret might have been compromised, you must generate a new Shared Secret to replace the old one. You can generate a new Shared Secret in the Community Platform</p>
<h5>To generate a new Shared Secret</h5>
<ol class="apidoc_ol">
  <li>Navigate to App Details &gt; Security Credentials.</li>
  <li>Click <strong>Regenerate Key</strong>.</li>
  <li>Copy the new key and use it in your app in place of the old one.</li>
</ol>
<p class="apidoc_note"><strong>Note</strong>: It might take up to five minutes for the new key to take effect. During that time, messages sent using the new key will fail. It's best to wait for five minutes before sending messages with the new key.</p>

<a name="createsshash_java"></a><h4>Java Example: Creating a Shared Secret Hash</h4>
<p>Below is an example of how to create the atmosphere_secret_digest value in Java.</p>
<pre class="apidoc_pre">  //Use the shared secret of app on file
String sharedSecret = "1008877afabf32efb31f9c974dbeaa688bed0769";

  //Generate the nonce value
Import java.security.SecureRandom:
Random rand =  SecureRandom.getInstance ("SHA1PRNG");
long nonce = rand.nextLong();

  //Get the timestamp in milliseconds
long timestamp = System.currentTimeMillis();
  
  // Concatenate the nonce, timestamp, and Shared Secret
String baseString = String.valueOf(nonce) + String.valueOf(timestamp) + sharedSecret;

  // Hash the concatenated value into a message digest using SHA-1
MessageDigest md = MessageDigest.getInstance("SHA1");
md.update(baseString.getBytes());
<!--
  // Convert digest bytes to text representation. Make sure no chunking is done
  // after 76 characters. The entire Base64-encoded digest should be in one line.
  // Apache commons coded library reference for Base64 class is available at:
  // http://commons.apache.org/codec/apidocs/org/apache/commons/codec/binary/Base64.htm
org.apache.commons.codec.binary.Base64 base64Obj = new org.apache.commons.codec.binary.Base64();
String digest = base64Obj.encodeBase64String(md.digest());
-->
// Encode the message digest using Base-64 encoding
String digest = encodeAsBase64String(md.digest());</pre>

<p><a href="#top">Back to top</a></p>
<hr>



<a name="authenticating_pki"></a><h3>Authenticating with PKI</h3>
<p>When you register your app in SOA Software Open, in the <em>Security Credentials</em> section of your <em>App Details</em> you'll see that the Shared Secret option is the default.</p>
<p>If you want to use Public Key Infrastructure (PKI) for secure message signing, click the button to choose Public Key Integration. You'll need to get a public/private key pair and upload the public key to SOA Software Open, as explained later in this document. In the custom app code you will sign the API requests using the private key. The API verifies each incoming request using the public key.</p>
<p>More information about authenticating with PKI is given in these  sections:</p>
<ul>
  <li><a href="#processflow_pki">Authenticating with PKI: Process Flow</a></li>
  <li><a href="#generatingkeypairwithopenssl">Generating a Public/Private Key Pair with OpenSSL</a></li>
  <li><a href="#java_keystorejdk">Java Developers: Generating a Keystore and CSR  with the JDK Keytool</a></li>
  <li><a href="#signing">Signing REST-Based Web Service Requests (PKI)</a></li>
  <li><a href="#composing">Composing the Signature</a></li>
</ul>
<a name="processflow_pki"></a><h4>Authenticating with PKI: Process Flow</h4>
<p> The process flow diagram below shows an overview of API request authentication with PKI.</p>
<p class="apidoc_image_p"><img src="images/processflow_apirequestauth_pki2.jpg" alt="Process flow: PKI security mechanism"></p>

<a name="generatingkeypairwithopenssl"></a><h4>Generating a Public/Private Key Pair with OpenSSL</h4>
<p>You can use the OpenSSL open source product to produce a public/private key pair. For more information on OpenSSL, refer to <a href="http://www.openssl.org" target="_blank">www.openssl.org</a>.</p>
<p> If you are developing the application using the Microsoft Windows OS you can get an adaptation of OpenSSL for the Windows platform from the following location: <a href="http://code.google.com/p/openssl-for-windows/downloads/list" target="_blank">http://code.google.com/p/openssl-for-windows/downloads/list</a>.</p>
<h5>To create a public/private key pair with OpenSSL</h5>
<ol class="apidoc_ol">
  <li>From the URL given above, download the applicable <strong>openssl</strong> archive file for your operating system.</li>
  <li>Unzip the contents to a folder; for example, <strong>C:\openssl</strong>.</li>
  <li>Launch the command-line utility <strong>cmd.exe</strong>.</li>
  <li>Change location to the folder referenced in step 2; for example, <strong>cd c:\openssl</strong>.</li>
<li>Cut and paste or type the following at the command prompt:
<pre class="apidoc_pre">
C:\openssl>bin\openssl req -config openssl.cnf -out csr.csr -new -newkey rsa:2048 -keyout privatekey.key</pre>
</li>
  <li>Enter data for the prompts that appear. 
<p class="apidoc_note2"><strong>Note</strong>: Anything with an empty bracket set [] is not required.</p>
</li></ol>
<p>Below is an example of what you might see in the command-line window.</p>
<p class="apidoc_image_p"><img src="images/generating_csr2.png" alt="Generating the CSR file"></p>
<p>This process creates your public/private key pair in the <strong>c:\openssl</strong> folder. The key pair includes the files shown below.</p>
<table width="98%" cellpadding="2" cellspacing="0" class="tableparmsresponse" summary="table description">
  <thead>
    <tr>
      <th width="18%">File name</th>
      <th width="14%">Key type</th>
      <th width="68%">Comments</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>privatekey.key</td>
      <td>private key</td>
      <td><p>Make sure you save a copy of the private key in a safe place. If you lose this key you will need to generate a new key pair.</p>
      <p>You will sign your request using the private key. For more information, see <a href="#composing">Composing the Signature</a>.</p></td>
  </tr>
    <tr>
      <td>csr.csr</td>
      <td>public key</td>
      <td>Upload this file to the SOA Software Open portal. The API uses this file to verify the signature of your requests.</td>
  </tr>
  </tbody>
</table>
<p class="apidoc_note"><strong>Important</strong>: Upload the file <strong>csr.csr</strong> to the SOA Software Open portal.</p>

<a name="java_keystorejdk"></a><h4>Java Developers: Generating a Keystore and CSR with the JDK Keytool</h4>
<p>If you are a Java  developer and have worked with cryptography in Java, you might be familiar with  the concept of a <strong><em>keystore</em></strong>. A keystore is  a file used to store and deploy certificates and private keys in a single package. You can create a keystore using OpenSSL as explained above. However, as a Java developer, it is probably far more convenient to use <strong><em>keytool</em></strong>, a key and certificate management utility that's  distributed as part of the Java Development Kit (JDK).</p>
<p>You can use keytool to create both the keystore  and the CSR associated with the private key in the keystore. Once you've created your CSR, you upload it to SOA Software Open just like any other CSR. Your Java code reads your private key, used  for signing the base string used in API request headers, from the keystore file  you create.</p>
<p>Since the keytool utility is    part of the JDK, you don't have to download anything to create your Java  keystore. Just follow the steps below.</p>
<p class="apidoc_note"><strong>Note</strong>: The procedure below assumes that your JDK <strong>bin</strong> directory is  in your Windows system path.</p>
<h5>To create a Java keystore using the keytool utility</h5>

<ol class="apidoc_ol">
  <li>Open a command prompt.</li>
  <li>Create the keystore file by typing the following:
  <p><strong>keytool -genkey -alias &lt;keystorealias&gt; -keyalg RSA -keystore  &lt;keystore_filename&gt;.p12 -storetype PKCS12 -keypass &lt;password&gt;  -keysize 2048</strong></p></li>
  <li>Create the CSR associated with the keystore created in step 2 by typing the  following:
  <p><strong>keytool -certreq -alias  &lt;keystorealias&gt; -keystore &lt;keystore_filename&gt;.p12 -file  &lt;csr_filename&gt;.csr -storetype PKCS12</strong></p></li>
</ol>
<p>The illustration  below shows the steps to create a keystore called <span class="apidoc_code">keystore.p12</span> with an alias of  <strong>mykeystore</strong> and the password <strong>changeme</strong>.</p>
<p class="apidoc_image_p"><img src="images/java_keytool_createkeystore.png" width="1040" alt="Creating a keystore with the Java keytool utility"></p>
<p>The illustration below shows how to  create a CSR called <strong>csr.csr</strong> from <strong>keystore.p12</strong>.</p>
<p class="apidoc_image_p"><img src="images/java_keytool_createcsr.png" width="811" height="106" alt="Creating a CSR with the Java keytool utility"></p>
<p class="apidoc_note"><strong>Note</strong>: For implementation examples, check the authentication documentation for the specific API you're using.</p>
<p class="apidoc_note"><strong>IMPORTANT :</strong> Upload the file <strong>CSR.csr</strong> to the SOA Software Open portal.</p>

<a name="signing"></a><h4>Signing REST-Based Web Service Requests (PKI)</h4>
<p>The signature process follows a similar approach to the <a href="http://tools.ietf.org/html/rfc5849" target="_blank">OAuth 1.0 standard</a>. The platform uses an HTTP Extension header to support its app authentication scheme. This Extension header is named Atmosphere (not case-sensitive). It uses the standard HTTP Authorization header and WWW-Authenticate response header to pass app-related authentication parameters. The HTTP query string can also be used to pass authentication data for cases where the app cannot directly manipulate HTTP headers.</p>
<h4>WWW-Authenticate header</h4>
<p> API providers can indicate their support for the extension by returning the SOA Software Open HTTP WWW-Authenticate header in response to app requests for protected resources. Below is an example:</p>
<pre class="apidoc_pre">
WWW-Authenticate: Atmosphere realm=&quot;http://atmosphere</pre>
<h4>Authorization  header</h4>
<p>Apps should send their credentials in the HTTP Authorization header. If you choose the Public Key Integration approach for your app security, your  HTTP Authorization header must include the values shown below.</p>
<p class="apidoc_note"><strong>Important</strong>: The sequence of the header attributes is critical and must exactly match the order below.</p>
<table class="tableparmsresponse" width="100%" cellspacing="0" cellpadding="2" summary="table description">
  <thead>
    <tr>
      <th width="25%">Name</th>
      <th width="20%">Data Type</th>
      <th width="55%">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>atmosphere_app_id</td>
      <td>String</td>
      <td>The AppID assigned to the app in the platform.</td>
  </tr>
    <tr>
      <td>atmosphere_nonce</td>
      <td>String</td>
      <td>A random string, uniquely generated for each request. The nonce allows the API providers to verify that a request has never been made before and helps prevent replay attacks when requests are made over a non-secure channel.</td>
  </tr>
    <tr>
      <td>atmosphere_signature_method</td>
      <td>String</td>
      <td>Indicates the signature method used. Valid values are <strong>SHA1withRSA</strong> or <strong>NONE</strong>. The <strong>NONE</strong> signature method is used for APIs that don't require security. In this case, only the atmosphere_app_id is required in the SOA Software Open HTTP Authorization headers.</td>
  </tr>
    <tr>
      <td>atmosphere_signature</td>
      <td>String</td>
      <td>The signature value. See next section for how the signature value is calculated.</td>
  </tr>
    <tr>
      <td>atmosphere_timestamp</td>
      <td>String</td>
      <td>The timestamp of the request, expressed as the number of milliseconds since January 1, 1970 00:00:00 GMT. The timestamp must be a positive integer and must be greater than or equal to the timestamp used in previous requests.</td>
  </tr>
    <tr>
      <td>atmosphere_version</td>
      <td>String</td>
      <td>The SOA Software Open version. Optional. If present, the valid value must be 1.0.</td>
  </tr>
  </tbody>
</table>
<h4> Sample header with authorization parameters (PKI approach)</h4>
<p>Below is an example of an Authorization header with app authentication parameters. Make sure you list the parameters in the sequence shown below.</p>
<p class="apidoc_note"><strong>Note</strong>: The value for the  realm is determined by the www-Authenticate header. Make sure the value you set in the Authorization: SOA Software Open header matches the value received for the attribute from the server.</p>
<pre class="apidoc_pre">Authorization: SOA Software Open realm="http://atmosphere",
  atmosphere_app_id="development-7FSXeNRkVRJ8XtAurgaea65R ",
  atmosphere_nonce="1323732744354",
  atmosphere_signature_method="SHA1withRSA",
  atmosphere_signature="wOJIO9A2W5mFwDgiDvZbTSMK%2FPY%3D",
  atmosphere_timestamp="1323732744354",
  atmosphere_version="1.0"</pre>
<h4> Sample header without authorization parameters</h4>
<p> Below is an example of an Authorization header for an API that doesn't require authentication:</p>
<pre class="apidoc_pre">
Authorization: SOA Software Open realm=&quot;http://atmosphere&quot;,
atmosphere_app_id=&quot;http://www.open.com/app/101&quot;,
atmosphere_signature_method=&quot;NONE&quot;</pre>
<p class="apidoc_note"><strong>Note</strong>: In case the client, such as an Ajax client in the browser or an Android app, cannot set the HTTP Authorization header, you can set the required SOA Software Open authorization header parameters in the HTTP query string.</p>

<a name="composing"></a><h4>Composing the Signature</h4>

<p>There are several steps to composing the signature:</p>
<ul>
  <li><a href="#constructingsbs">Creating the Signature Base String</a></li>
  <li><a href="#signingandencoding">Signing the Signature Base String and Encoding the Signature</a></li>
</ul>
<a name="constructingsbs"></a><h4>Creating the Signature Base String</h4>
<p>The first step in composing the digital signature is to create the content. Once that's done, the data is signed using the signature algorithm.</p>
<p class="apidoc_note"><strong>Note</strong>: The atmosphere_signature parameter <em>must</em> be excluded from the Signature Base String.</p>
<p>Below is an example of the Signature Base String.</p>
<pre class="apidoc_pre">
POST&amp;https://api.sandbox.yoursandbox.com/APIName/Payment/v1/MethodName
&amp;atmosphere_app_id=Atmosphere-7FSXeNRkVRJ8XtAurgaea65R
&amp;atmosphere_nonce=1323732744354&amp;atmosphere_signature_method=SHA1withRSA
&amp;atmosphere_timestamp=1323732744354&amp;atmosphere_version=1.0</pre>
<a name="signingandencoding"></a><h4>Signing the Signature Base String and Encoding the Signature</h4>
<p>Once the Signature Base String is constructed, the next step is  signing:</p>
<ol class="apidoc_ol">
  <li>Use the SHA-1 algorithm  to generate the hash of the Signature Base String.</li>
  <li>Sign  the hashed value  using the private key of the app.</li>
  <li>Base64-encode the signature value.
  <span class="apidoc_note"><strong>Note:</strong> Base64 encoding should <em>not</em> include the CRLF (carriage return/line feed) every 72 characters which is part of strict Base64 encoding. Instead, the whole Base64 encoded string should be without line breaks.</span>
</li>
  <li>Optionally, URL-encode the result into a string.</li>
  <li>Set the string as the value for the atmosphere_signature parameter.</li>
</ol>


<p><a href="#top">Back to top</a></p>
<hr>



<a name="headerexamplebothapproaches"></a><h3>Header Example for Both Approaches</h3>
<p>The example below shows the same message header as it would be if created with each approach.</p>
<p>Some parameters are common to both approaches:</p>
<ul>
  <li>realm</li>
  <li>atmosphere_app_id</li>
  <li>atmosphere_nonce</li>
  <li>atmosphere_timestamp</li>
  <li>atmosphere_version</li>
</ul>
<h4>Shared Secret Approach</h4>
<p>In the example below, the message header uses the Shared Secret approach, with a Shared Secret value of <strong>1008877afabf32efb31f9c974dbeaa688bed0769</strong>. The atmosphere_secret_digest value is the hashed value of nonce + timestamp + shared secret.</p>
<pre class="apidoc_pre">Atmosphere realm=&quot;http://atmosphere&quot;,
atmosphere_app_id=&quot;Atmosphere-2f97rkSViLn6yd7syPtRiG7q&quot;,
atmosphere_nonce=&quot;1328745832972&quot;,
atmosphere_timestamp=&quot;1328745832972&quot;,
atmosphere_digest_method=&quot;SHA1&quot;,
atmosphere_secret_digest=&quot;fr3u4BCMJv03THDqsj5c6RQMUWk=&quot;,
atmosphere_version=&quot;1.0&quot;</pre>

<h4>PKI Approach</h4>
<p>In the example below, the message header uses the  PKI approach. The atmosphere-signature value is the signed value of the signature base string (see <a href="#constructingsbs">signature base string</a>).</p>
<pre class="apidoc_pre">
Atmosphere realm="http://atmosphere",
atmosphere_app_id="Atmosphere-2f97rkSViLn6yd7syPtRiG7q&quot;,
atmosphere_nonce=&quot;1328745832972&quot;,
atmosphere_timestamp=&quot;1328745832972&quot;
atmosphere_signature_method="SHA1withRSA",
atmosphere_signature="XKYtUsH7ta8I5mbZaZebm4b6NLjAVSGcK3op9lJxWC%2FlpNLxAm1GoHoMkKzLUh
  %2BN7QdEBjR6ufgKMD%2BTWK4fPT2uXbHWNuOOTM4qUizrRymPxuAXEWhmECEB4WL7zr9UmWG7OGDsyuDUOt
  93nAnVvfqinF0bC%2FnWBAH%2FelZlX%2FUMtO29%2BNrMq7ep0B%2BWKEosJmCFBtfgk72kRYl5rKsDqDm2m
  gIFyHPWoFvC5WJiqtXTqGEaNxSbdWweaCaLqHNRnXowozOLMYYnnEd%2FTSFF0E5CrJBTzOq5Wvixnt6iJqWE
  J0ywIc%2FPjVFs5muYOv30Lno44F0w6b3vjKTHWOJHEg%3D%3D",
atmosphere_version="1.0"
</pre>
<p><a href="#top">Back to top</a></p>

<div class = "divider1"></div>
